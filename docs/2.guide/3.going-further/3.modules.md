---
title: "Module Author Guide"
description: "Learn how to create a Nuxt module to integrate, enhance or extend any Nuxt applications."
---

# Module Author Guide

Learn how to create a Nuxt module to integrate, enhance or extend any Nuxt applications.

Nuxt's [configuration](/docs/api/configuration/nuxt-config) and [hooks](/docs/guide/going-further/hooks) systems make it possible to customize every aspect of Nuxt and add any integration you might need (Vue plugins, CMS, server routes, components, logging, etc.).

It exposes a powerful API called **Nuxt Modules**: they are functions that sequentially run when starting Nuxt in development mode using `nuxi dev` or building a project for production with `nuxi build`.
With modules, you can encapsulate, properly test, and share custom solutions as npm packages without adding unnecessary boilerplate to the Nuxt project itself.

## Quick Start

We recommend you get started with Nuxt Modules using our [starter template](https://github.com/nuxt/starter/tree/module):

```bash
npx nuxi init -t module my-module
```

This will create a `my-module` project with all the boilerplate necessary to develop and publish your module.

**Next steps:**

1. Open `my-module` in your IDE of choice
2. Install dependencies using your favorite package manager
3. Prepare local files for development using `npm run dev:prepare`
4. Start the playground to develop your module on using `npm run dev`
5. Follow this document to learn more about Nuxt modules

## Developing Modules

Nuxt Modules come with a variety of powerful API and patterns allowing them to alter a Nuxt application in pretty much any way possible. This section teaches you how to take advantage of those.

::alert{type=info}
This section assumes you're using the module starter presented above or that you're already familiar with module development.
::

### Basics

#### How to Develop

While your module source code lives inside the `src` directory, in most cases, to develop a module, you need a Nuxt application. That's what the `playground` directory is about. It's a Nuxt application you can tinker with that is already configured to run with your module.

You can interact with the playground like with any Nuxt application.

- Launch its development server with `npm run dev`, it should reload itself as you make changes to your module
- Build it with `npm run dev:build`

::alert{type=info}
All other `nuxi` commands can be used against the `playground` directory (e.g. `nuxi <COMMAND> playground`). Feel free to declare additional `dev:*` scripts within your `package.json` referencing them for convenience.
::

#### How to Build

Nuxt Modules come with their own builder provided by [`@nuxt/module-builer`](https://github.com/nuxt/module-builder#-nuxt-module-builder). This builder doesn't require any configuration on your end, supports TypeScript, and makes sure your assets are properly bundled to be distributed to other Nuxt applications.

You can build your module by running `npm run prepack`.

::alert{type=info}
While build your module can be useful in some cases, most of the time you won't need to build it on your own: the `playground` takes care of it while developing, and the release script also have you covered when publishing.
::

#### How to Publish

::alert
Before publishing your module to npm, makes sure you have an [npmjs.com](https://www.npmjs.com) account and that you're authenticated to it locally with `npm login`.
::

While you can publish your module by bumping its version and using the `npm publish` command, the module starter comes with a release script that helps you make sure you publish a working version of your module to npm and more.

To use the release script, first commit all your changes (we recommend you follow [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0) to take advantage of automatic version bump and changelog update), then run the release script with `npm run release`.

When running the release script, the following will happen:

- First, it will run your test suite by:
  - Running the linter (`npm run lint`)
  - Running unit, integration, and e2e tests (`npm run test`)
  - Building the module (`npm run prepack`)
- Then, if your test suite went well, it will proceed to publish your module by:
  - Bumping your module version and generating changelog according to your Conventional Commits
  - Publishing the module to npm (for that purpose, the module will be built again to ensure its updated version number is taken into account in the published artifact)
  - Pushing a git tag representing the new published version to your git remote origin

::alert{type=info}
As with other scripts, feel free to fine tune the default `release` script in your `package.json` to better suit your need.
::

### Module Anatomy

Your module source code lives inside the `src` directory.

#### Module Definition

`src/module.ts` contains your module definition. It's the entry point of your module and what gets loaded by Nuxt when your module is referenced within a Nuxt configuration.

At a low level, a Nuxt module definition is a simple function accepting inline user options and a `nuxt` object to interact with the Nuxt application.

```js
export default async function (inlineOptions, nuxt) {
  // You can do whatever you like here..
  console.log(inlineOptions.token) // `123`
  console.log(nuxt.options.dev) // `true` or `false`
  nuxt.hook('ready', async nuxt => {
    console.log('Nuxt is ready')
  })
}
```

However, to define a module, we do recomend to use the higher level `defineNuxtModule` helper provided by [Nuxt Kit](/docs/api/advanced/kit). This helper makes writting Nuxt module more straightforward by implementing many convenience patterns seen in modules, guaranteeing future compatibility, and improving your module author developer experience and the one of your module users.

```js
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    // Usually the npm package name of your module
    name: '@nuxtjs/example',
    // The key in `nuxt.config` that holds your module options
    configKey: 'sample',
    // Compatibility constraints
    compatibility: {
      // Semver version of supported nuxt versions
      nuxt: '^3.0.0'
    }
  },
  // Default configuration options for your module, can also be a function returning those
  defaults: {},
  // Shorthand sugar to register Nuxt hooks
  hooks: {},
  // The function holding your module logic, it can be asynchronous
  setup(moduleOptions, nuxt) {
    // ...
  }
})
```

Ultimately `defineNuxtModule` returns a wrapper function with the lower level `(inlineOptions, nuxt)` module signature. This wrapper function applies defaults and other necessary steps before calling the `setup` function:

::list
- Support `defaults` and `meta.configKey` for automatically merging module options
- Type hints and automated type inference
- Add shims for basic Nuxt 2 compatibility
- Ensure module gets installed only once using a unique key computed from `meta.name` or `meta.configKey`
- Automatically register Nuxt hooks
- Automatically check for compatibility issues based on module meta
- Expose `getOptions` and `getMeta` for internal usage of Nuxt
- Ensuring backward and upward compatibility as long as the module is using `defineNuxtModule` from the latest version of `@nuxt/kit`
- Integration with module builder tooling
::

::alert{type=info}
While most modules are presented as npm packages, you can have "local" modules within a Nuxt project. To achieve so, create a `~/modules/my-module.ts` file exporting a module definition, then register it within your Nuxt configuration.
::

#### Runtime Directory

Modules, like everything in a Nuxt configuration, aren't included in your application runtime. Although, you might want your module to provide, or inject runtime code to the application it's installed on. That's what the `src/runtime` directory enables you to do.

Inside the runtime directory you can provide any kind of assets: Vue components, [plugins](/docs/guide/directory-structure/plugins), stylesheets, or even 3D models. You'll then be able to inject them inside the application from your [module definition](#module-definition)

::alert{type=info}
Learn more about asset injection in the [recipes](#recipes) section.
::

### Tooling

Explaining the common tools used to author modules, just the big picture, not in depths

- `@nuxt/module-builder`
- `@nuxt/kit`
- `@nuxt/test-utils`

### Recipes

Sharing common patterns used to author modules (known as _"Examples"_ today)

- Exposing options to runtime
- Injecting plugins with `addPlugin`
- Injecting Vue components with `addComponent`
- Inject other assets
- Adding auto imports
- Using hooks (+ module cleanup)

### Testing

Sharing some testing strategies and how-tos

- Unit & integration (mocking)
- End to End (`@nuxt/test-utils`)
- Manual QA with playground & externally

### Best Practices

Quite similar to the current one, maybe I'd add a note on considering keeping the default (linter, etc.) so that public module code style all feels "alike"

## Ecosystem

Presenting the ecosystem

- Modules page on the doc / how to be listed
- Official modules (`@nuxt/*`)
- Community modules (`@nuxtjs/*`) / modules org on GitHub / how to join
- Other community modules (`nuxt-*`) / maybe touching slighly on that people can make "personal" modules at their companies for various reasons and that that's a pattern
- Contributing to the ecosystem (making it obvious anyone is welcome to improve existing modules)

## Module internals

Maybe just a quick section touching on "how modules work" under the hood, priority, etc.
